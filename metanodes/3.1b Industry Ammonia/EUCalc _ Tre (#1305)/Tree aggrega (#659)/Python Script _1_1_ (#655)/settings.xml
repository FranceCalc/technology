<?xml version="1.0" encoding="UTF-8"?>
<config xmlns="http://www.knime.org/2008/09/XMLConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.knime.org/2008/09/XMLConfig http://www.knime.org/XMLConfig_2008_09.xsd" key="settings.xml">
<entry key="node_file" type="xstring" value="settings.xml"/>
<config key="flow_stack"/>
<config key="internal_node_subsettings">
<entry key="memory_policy" type="xstring" value="CacheSmallInMemory"/>
</config>
<config key="model">
<entry key="sourceCode" type="xstring" value="import pandas as pd%%00010import re%%00010%%00010def aggregate(df, unit_var, aggregation_method, index_pattern, aggregation_pattern, new_name_start, aggregation_remove, caller):%%00010    &quot;&quot;&quot; Written by Azfar Umer and Cartuyvels Jacques under the supervision of Matton Vincent (vm @ climact.com)%%00010            August - September%%00010            2018, Climact, Louvain - La - Neuve%%00010            ----------%%00010            Auxiliary function called by the EUCalc split and parallel op nodes&quot;&quot;&quot;%%00010%%00010    column_pairs = &quot;&quot;%%00010    list_of_columns_1 = []%%00010    list_of_columns_2 = []%%00010    new_columns_list = &quot;&quot;%%00010    id_double = 1%%00010%%00010    column_names = list(df.columns.values)%%00010%%00010    pattern_i = re.compile(index_pattern)%%00010    pattern_a = re.compile(aggregation_pattern)%%00010    pattern_u = re.compile(&quot;.*\\[(.*)].*&quot;)%%00010%%00010    list_of_names_with_conflicts = []%%00010%%00010    isMatching1 = False%%00010%%00010    for column_name_1 in column_names:%%00010        matcher1 = re.match(pattern_i, column_name_1)%%00010        matcher_unit = re.match(pattern_u, column_name_1)%%00010%%00010        colUnit = unit_var%%00010%%00010        if matcher_unit and colUnit == &quot;unit&quot;:%%00010            colUnit = matcher_unit.group(1)%%00010%%00010        if matcher1:%%00010            isMatching1 = True%%00010            iterator1 = matcher1.group(1)%%00010            numberGroups1 = len(matcher1.groups())%%00010%%00010            isMatching2 = False%%00010            matchingIterator = False%%00010            # numberGroups = pattern_a.groups%%00010            numberGroups2 = 0%%00010%%00010            for column_name_2 in column_names:%%00010                matcher2 = re.match(pattern_a, column_name_2)%%00010%%00010                if matcher2:%%00010                    numberGroups2 = len(matcher2.groups())%%00010                    isMatching2 = True%%00010%%00010                    if numberGroups2 == 0:  # Tree split%%00010%%00010                        new_name = new_name_start + &quot;_&quot; + iterator1 + &quot;[&quot; + colUnit + &quot;]&quot;%%00010                        if new_name in new_columns_list or new_name in column_names:%%00010                            #raise Exception(&quot;A column with name &quot; + new_name + &quot; already exists!&quot;)%%00010                            if new_name in column_names:%%00010                                list_of_names_with_conflicts.append(new_name)%%00010                            new_name = new_name + &quot; (#&quot;+ str(id_double) + &quot;)&quot;%%00010                            id_double +=1%%00010%%00010                        new_columns_list = new_columns_list + new_name + &quot;,&quot;%%00010                        #columns_used = columns_used + column_name_1 + &quot;,&quot; + column_name_2 + &quot;,&quot;%%00010%%00010                        if column_name_1 not in list_of_columns_1:%%00010                            list_of_columns_1.append(column_name_1)%%00010%%00010                        if column_name_2 not in list_of_columns_2:%%00010                            list_of_columns_2.append(column_name_2)%%00010%%00010                        column_pairs = column_pairs + column_name_1 + &quot;,&quot; + column_name_2 + &quot;;&quot;%%00010%%00010                    elif numberGroups2 == 1 or numberGroups2 == 2:  # Parallel operation%%00010                        if caller == 'SPLIT':%%00010                            raise Exception(&quot;Number of capture groups in aggregation pattern for a tree split node must be 0&quot;)%%00010%%00010%%00010                        iterator2 = matcher2.group(1)%%00010                        if iterator1 == iterator2:%%00010                            matchingIterator = True%%00010%%00010                            new_name = new_name_start + '_' + iterator1%%00010%%00010                            if numberGroups1 == 2:%%00010                                new_name = new_name + &quot;_&quot; + matcher1.group(2)%%00010                            if numberGroups2 == 2:%%00010                                new_name = new_name + &quot;_&quot; + matcher2.group(2)%%00010%%00010                            new_name = new_name + &quot;[&quot; + colUnit + &quot;]&quot;%%00010                            if new_name in new_columns_list or new_name in column_names:%%00010                                #raise Exception(&quot;A column with name &quot; + new_name + &quot; already exists!&quot;)%%00010                                if new_name in column_names:%%00010                                   list_of_names_with_conflicts.append(new_name)%%00010                                new_name = new_name + &quot; (#1)&quot;%%00010                            new_columns_list = new_columns_list + new_name + &quot;,&quot;%%00010%%00010                            if column_name_1 not in list_of_columns_1:%%00010                                list_of_columns_1.append(column_name_1)%%00010%%00010                            if column_name_2 not in list_of_columns_2:%%00010                                list_of_columns_2.append(column_name_2)%%00010%%00010                            column_pairs = column_pairs + column_name_1 + &quot;,&quot; + column_name_2 + &quot;;&quot;%%00010%%00010                    else:%%00010                        raise Exception(&quot;Number of capture groups in aggregation pattern cannot be more than 2&quot;)%%00010%%00010            if not isMatching2:%%00010                raise Exception(&quot;No match found in input columns for pattern '&quot; + aggregation_pattern + &quot;'&quot;)%%00010%%00010            if not matchingIterator and numberGroups2 == 1:%%00010                raise Exception(&quot;Iterator not found in second column group: '&quot; + iterator1 + &quot;'&quot;)%%00010%%00010    if not isMatching1:%%00010        raise Exception(&quot;No match found in input columns for pattern \&quot;&quot; + index_pattern + &quot;\&quot;&quot;)%%00010%%00010    # perform computations and store results:%%00010%%00010    list_of_column_pairs = column_pairs.split(&quot;;&quot;)%%00010    del list_of_column_pairs[-1]%%00010    list_of_new_column_names = new_columns_list.split(&quot;,&quot;)%%00010    del list_of_new_column_names[-1]%%00010%%00010    output = {}%%00010%%00010    i = 0%%00010    for pair in list_of_column_pairs:%%00010        col_name_1, col_name_2 = pair.split(&quot;,&quot;)%%00010       %%00010        if aggregation_method == 'Product':%%00010            output[list_of_new_column_names[i]] = df[col_name_1].astype(float) * df[col_name_2].astype(float)%%00010        elif aggregation_method == 'Sum':%%00010            output[list_of_new_column_names[i]] = df[col_name_1].astype(float) + df[col_name_2].astype(float)%%00010        elif aggregation_method == &quot;Division 1/2&quot;:%%00010            output[list_of_new_column_names[i]] = df[col_name_1].astype(float) / df[col_name_2].astype(float)%%00010        elif aggregation_method == &quot;Division 2/1&quot;:%%00010            output[list_of_new_column_names[i]] = df[col_name_2].astype(float) / df[col_name_1].astype(float)%%00010        elif aggregation_method == &quot;Subtraction 1-2&quot;:%%00010            output[list_of_new_column_names[i]] = df[col_name_1].astype(float) - df[col_name_2].astype(float)  %%00010        elif aggregation_method == &quot;Subtraction 2-1&quot;:%%00010            output[list_of_new_column_names[i]] = df[col_name_2].astype(float) - df[col_name_1].astype(float)        %%00010        else:%%00010            raise Exception(&quot;Unknown aggregation method!&quot;)%%00010%%00010        i = i + 1%%00010%%00010    output = pd.DataFrame.from_dict(output)%%00010%%00010    # The awkward formulation below ensures that the order of the columns is the same as in the knime output%%00010%%00010    #print(list(df.columns))%%00010    #print(list_of_names_with_conflicts)%%00010    df_conflicts = df[list_of_names_with_conflicts]%%00010    df_used_1 = df[list_of_columns_1]%%00010    df_used_2 = df[list_of_columns_2]%%00010    df = df.drop(list_of_columns_1, axis=1)%%00010    df = df.drop(list_of_columns_2, axis=1)%%00010%%00010    if aggregation_remove != 1:%%00010%%00010        df = df.join(df_used_1)%%00010        df = df.join(df_used_2)%%00010    else:%%00010        df = df.join(df_conflicts)%%00010%%00010    return df.join(output)%%00010%%00010output_table = aggregate(input_table, flow_variables['unit_var'],flow_variables['aggregation_method'],flow_variables['index_pattern'],flow_variables['aggregation_pattern'],flow_variables['new_name_start'],flow_variables['aggregation-remove'],flow_variables['tree_caller'])"/>
<entry key="rowLimit" type="xint" value="1000"/>
<entry key="pythonVersionOption" type="xstring" value="PYTHON3"/>
<entry key="convertMissingToPython" type="xboolean" value="false"/>
<entry key="convertMissingFromPython" type="xboolean" value="false"/>
<entry key="sentinelOption" type="xstring" value="MIN_VAL"/>
<entry key="sentinelValue" type="xint" value="0"/>
<entry key="chunkSize" type="xint" value="500000"/>
</config>
<entry key="customDescription" type="xstring" isnull="true" value=""/>
<entry key="state" type="xstring" value="IDLE"/>
<entry key="factory" type="xstring" value="org.knime.python2.nodes.script.Python2ScriptNodeFactory"/>
<entry key="node-name" type="xstring" value="Python Script (1⇒1)"/>
<entry key="node-bundle-name" type="xstring" value="KNIME Python nodes"/>
<entry key="node-bundle-symbolic-name" type="xstring" value="org.knime.python2.nodes"/>
<entry key="node-bundle-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-bundle-version" type="xstring" value="3.6.1.v201808311614"/>
<entry key="node-feature-name" type="xstring" value="KNIME Python Integration"/>
<entry key="node-feature-symbolic-name" type="xstring" value="org.knime.features.python2.feature.group"/>
<entry key="node-feature-vendor" type="xstring" value="KNIME AG, Zurich, Switzerland"/>
<entry key="node-feature-version" type="xstring" value="3.6.2.v201811051558"/>
<config key="factory_settings"/>
<entry key="name" type="xstring" value="Python Script (1⇒1)"/>
<entry key="hasContent" type="xboolean" value="false"/>
<entry key="isInactive" type="xboolean" value="false"/>
<config key="ports">
<config key="port_1">
<entry key="index" type="xint" value="1"/>
<entry key="port_dir_location" type="xstring" isnull="true" value=""/>
</config>
</config>
<config key="filestores">
<entry key="file_store_location" type="xstring" isnull="true" value=""/>
<entry key="file_store_id" type="xstring" isnull="true" value=""/>
</config>
</config>
